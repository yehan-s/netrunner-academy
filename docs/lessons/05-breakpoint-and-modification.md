# 第五课：流量拦截与修改（断点功能）

## 什么是断点（Breakpoint）？

**类比编程调试**：

```
代码调试器               抓包工具断点
├── 在函数入口打断点     ├── 在请求发送前打断点
├── 检查变量值           ├── 检查请求参数
├── 修改变量             ├── 修改请求内容
└── 继续执行             └── 发送修改后的请求
```

**核心作用**：在请求/响应传输过程中暂停，允许你**实时修改**数据后再继续。

---

## 断点的两种类型

### 1. 请求断点（Request Breakpoint）

**拦截时机**：客户端发送请求 → **暂停** → 代理工具 → 服务器

**使用场景**：

- 修改请求参数（测试不同的输入）
- 修改请求头（伪造 User-Agent、Authorization）
- 修改请求体（篡改提交的数据）

**示例**：

```
原始请求:
POST /api/checkout
Content-Type: application/json

{"itemId": 1001, "price": 99.99, "quantity": 1}

↓ 拦截后修改 ↓

修改后:
{"itemId": 1001, "price": 0.01, "quantity": 1}  ← 修改价格为 0.01 元
```

### 2. 响应断点（Response Breakpoint）

**拦截时机**：服务器返回响应 → **暂停** → 代理工具 → 客户端

**使用场景**：

- 模拟错误响应（测试前端错误处理）
- 修改响应数据（伪造会员状态、权限）
- 注入调试信息（在 HTML 中插入脚本）

**示例**：

```
原始响应:
HTTP/1.1 200 OK
Content-Type: application/json

{"isVip": false, "balance": 0}

↓ 拦截后修改 ↓

修改后:
{"isVip": true, "balance": 999999}  ← 伪造 VIP 状态和余额
```

---

## Reqable 断点功能详解

### 激活断点

**步骤**：

1. 在请求列表中找到目标请求
2. **右键** → 选择 **"设置断点"** 或点击工具栏的 **断点图标**
3. 再次发起请求时，Reqable 会自动暂停

**断点规则设置**：

```
按 URL 匹配:   https://api.example.com/checkout
按域名匹配:   api.example.com
按路径匹配:   /api/*
按方法匹配:   POST
```

### 断点界面

当请求被拦截时，Reqable 会显示：

```
┌─ 断点模式 ─────────────────────────────┐
│ 🔴 已拦截请求                          │
│                                        │
│ [原始] [修改] [预览]  ← 三个标签页     │
│                                        │
│ ┌──────────────────────────────────┐  │
│ │ POST /api/checkout HTTP/1.1      │  │
│ │ Host: api.example.com            │  │
│ │ Content-Type: application/json   │  │
│ │                                  │  │
│ │ {"itemId": 1001, "price": 99.99} │  │ ← 可编辑
│ └──────────────────────────────────┘  │
│                                        │
│ [继续发送]  [取消]  [保存修改]        │
└────────────────────────────────────────┘
```

---

## 实战案例

### 案例 1：测试价格篡改漏洞

**场景**：电商网站下单时，价格是否由前端提交？

**步骤**：

1. **正常下单流程**：
   - 添加商品到购物车（价格 99.99 元）
   - 点击"结算"

2. **设置断点**：
   - 在 Reqable 中找到 `POST /api/checkout` 请求
   - 右键 → **"设置断点"**

3. **再次下单**：
   - 点击"结算"
   - Reqable 拦截请求，显示：
     ```json
     {
       "itemId": 1001,
       "price": 99.99,
       "quantity": 1
     }
     ```

4. **修改价格**：
   - 将 `"price": 99.99` 改为 `"price": 0.01`
   - 点击 **"继续发送"**

5. **观察结果**：
   - ✅ **安全的后端**：返回 `400 Bad Request`，提示"价格验证失败"
   - ❌ **有漏洞的后端**：返回 `200 OK`，订单创建成功，价格为 0.01 元

**安全建议**：价格等关键数据**必须由后端计算**，前端提交的价格仅用于显示校验。

---

### 案例 2：绕过前端验证

**场景**：网站限制用户名只能 3-10 个字符，但后端是否校验？

**步骤**：

1. **前端尝试**：
   - 输入 2 个字符的用户名 `"ab"`
   - 前端 JavaScript 阻止提交，提示"用户名过短"

2. **使用断点绕过**：
   - 输入任意合法用户名（如 `"test"`）触发提交
   - Reqable 拦截 `POST /api/register` 请求
   - 修改请求体：
     ```json
     {
       "username": "ab",  ← 改为 2 个字符
       "password": "123456"
     }
     ```
   - 点击"继续发送"

3. **结果分析**：
   - ✅ **安全的后端**：返回 `400 Bad Request`，提示"用户名长度不符"
   - ❌ **有漏洞的后端**：注册成功，创建了 2 个字符的用户名

**教训**：前端验证仅为用户体验，后端**必须重新验证**所有数据。

---

### 案例 3：模拟网络错误

**场景**：测试前端是否正确处理服务器错误。

**步骤**：

1. **正常请求**：
   - 访问 `/api/user/profile`
   - 服务器返回 `200 OK` + 用户数据

2. **设置响应断点**：
   - 在 Reqable 中设置 `/api/user/profile` 的响应断点

3. **修改响应**：
   - 拦截响应后，修改状态码为 `500 Internal Server Error`
   - 修改响应体为：
     ```json
     {"error": "Database connection failed"}
     ```

4. **观察前端**：
   - ✅ **健壮的前端**：显示友好错误提示"服务器繁忙，请稍后再试"
   - ❌ **脆弱的前端**：页面崩溃或显示技术错误信息

---

### 案例 4：伪造会员状态

**场景**：测试前端是否信任服务器返回的会员状态。

**步骤**：

1. **获取用户信息**：
   - 请求 `GET /api/user/profile`
   - 响应：
     ```json
     {
       "username": "alice",
       "isVip": false,
       "vipExpireDate": null
     }
     ```

2. **设置响应断点**：
   - 在 Reqable 中拦截响应

3. **修改响应**：
   ```json
   {
     "username": "alice",
     "isVip": true,          ← 改为 VIP
     "vipExpireDate": "2099-12-31"
   }
   ```

4. **观察前端**：
   - 前端可能显示"VIP 专属"功能（仅 UI 层面）
   - **但实际权限仍由后端控制**（如下单时后端会再次验证）

**结论**：前端显示的权限状态可以伪造，但**真正的权限校验必须在后端**。

---

## 高级技巧

### 1. 批量修改规则

**场景**：所有请求都添加自定义 Header。

**Reqable 规则配置**：

```yaml
规则名称: 添加调试 Header
触发条件: 所有请求
修改内容:
  添加 Header:
    X-Debug-Mode: true
    X-User-Role: admin
```

**效果**：所有经过代理的请求自动添加这些 Header。

### 2. 模拟慢速网络

**场景**：测试前端在慢速网络下的加载效果。

**Reqable 延迟设置**：

```
请求延迟: 2000ms
响应延迟: 3000ms
```

**观察**：页面加载变慢，测试 Loading 动画是否正常。

### 3. 自动替换响应

**场景**：将生产环境 API 的响应替换为本地 Mock 数据。

**规则配置**：

```yaml
规则名称: Mock 用户数据
触发条件: GET https://api.example.com/user/profile
修改内容:
  替换响应体为:
    {
      "username": "test-user",
      "isVip": true,
      "balance": 10000
    }
```

**优势**：无需修改前端代码，即可使用 Mock 数据调试。

---

## 安全与道德提醒

### ✅ 合法使用场景

- **自己开发的项目**：调试和测试
- **授权的安全测试**：渗透测试、Bug Bounty
- **学习目的**：在本地测试环境练习

### ❌ 禁止行为

- **破解付费软件**：篡改购买验证请求
- **作弊游戏**：修改游戏数据
- **恶意攻击**：未授权修改他人网站数据
- **盗窃信息**：拦截并窃取他人的登录凭证

**法律风险**：未经授权的网络攻击行为可能触犯《网络安全法》等法律法规。

---

## 常见问题

### Q: 为什么有些请求无法拦截？

**A**: 可能原因：

1. **应用未走代理**：检查系统代理设置
2. **证书未信任**：HTTPS 请求需要安装证书
3. **证书固定（Certificate Pinning）**：部分 App 强制验证服务器证书，拒绝代理

### Q: 修改后的请求会影响后续请求吗？

**A**: 不会。断点修改仅影响**当前这一次**请求，下次请求仍使用原始数据（除非设置了持久规则）。

### Q: 如何保存常用的修改规则？

**A**: 使用 Reqable 的"**重写规则（Rewrite Rules）**"功能：

1. 创建规则 → 设置匹配条件 → 定义修改内容
2. 规则会自动应用于所有匹配的请求

---

## 实战练习

### 练习 1：测试登录接口的密码加密

**任务**：检查密码是否加密传输。

**步骤**：

1. 在登录页面输入密码 `123456`
2. 设置 `POST /api/login` 的请求断点
3. 查看请求体：
   - ❌ 明文传输：`{"password": "123456"}`
   - ✅ 加密传输：`{"password": "e10adc3949ba59abbe56e057f20f883e"}` (MD5 Hash)

### 练习 2：绕过前端限流

**场景**：网站限制 1 分钟内只能发送 3 次验证码。

**步骤**：

1. 正常发送 3 次验证码后，前端按钮变灰，无法点击
2. 使用 Reqable 的 **Composer** 功能：
   - 复制 `POST /api/send-code` 请求
   - 手动发送第 4 次、第 5 次...
3. 观察后端是否限流：
   - ✅ **安全的后端**：返回 `429 Too Many Requests`
   - ❌ **有漏洞的后端**：继续发送验证码

### 练习 3：模拟服务器错误

**任务**：测试前端对 500 错误的处理。

**步骤**：

1. 访问任意页面，找到核心 API 请求
2. 设置响应断点，修改状态码为 `500`
3. 修改响应体为：`{"error": "Internal Server Error"}`
4. 观察前端是否有友好提示

---

## 小结

✅ 你已经掌握：

- 断点的两种类型（请求/响应）
- Reqable 断点功能的使用
- 实战案例：价格篡改、绕过验证、模拟错误
- 高级技巧：批量规则、慢速网络、自动替换
- 安全与道德规范

下一课：

- 📘 [第六课：HTTPS 证书配置](./06-https-certificate-setup.md)
- 📘 [第七课：安全测试入门](./07-security-testing-basics.md)

---

## 延伸阅读

- [Reqable 断点功能文档](https://reqable.com/docs/breakpoint)
- [OWASP Top 10 安全风险](https://owasp.org/www-project-top-ten/)
- [Web 安全测试指南](https://owasp.org/www-project-web-security-testing-guide/)
